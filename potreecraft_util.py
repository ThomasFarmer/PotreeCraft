import logging
import threading
import time
import subprocess
import random

#import win32file
from datetime import datetime, date
import os
import shutil

from qgis._core import QgsProject, QgsMapLayer, QgsPoint, QgsDistanceArea, QgsPointXY, QgsUnitTypes, QgsSpatialIndex, \
    QgsCoordinateReferenceSystem


class PotreeCraftSupport:

    lastoolspath = None
    potreeconverterpath = None

    vectorLayers = None
    rasterLayers = None

    def __init__(self):
        print(os.path.dirname(os.path.abspath(__file__)))
        print(os.getcwd())



    @classmethod
    def readcfg(cls):
        try:
            configfile = open(os.path.dirname(os.path.abspath(__file__))+"/potreecraft_config.ini", "r+")
            configz = configfile.readlines()
            # print(configz[0].split('"')[1])
            # print(configz[1].split('"')[1])
            cls.lastoolspath = configz[0].split('"')[1]
            cls.potreeconverterpath = configz[1].split('"')[1]
            if cls.potreeconverterpath[-1] != '\\':
                cls.potreeconverterpath += "\\"
            if cls.lastoolspath[-1] != '\\':
                cls.lastoolspath += '\\'
            print('LASTools folder path: '+cls.lastoolspath)
            print('PotreeConverter folder path: '+cls.potreeconverterpath)
            return [cls.lastoolspath, cls.potreeconverterpath]
        except Exception as genex:
            print(genex)
            print("Using default values for tool paths:")
            return ["c:\\LAStools\\", "c:\\PotreeConverter_16\\"]


    @classmethod
    def readwholefile(self):
        configfile = open(os.path.dirname(os.path.abspath(__file__))+"/potreecraft_config.ini", "r+")
        configz = configfile.readlines()
        return configz

    @classmethod
    def writecfg(cls,lastoolspath,pcpath):
        configfile = open(os.path.dirname(os.path.abspath(__file__))+"/potreecraft_config.ini", "w")
        pcpath = pcpath.replace("/","\\")
        lastoolspath = lastoolspath.replace("/","\\")
        if pcpath[-1] != '\\':
            pcpath += "\\"
        if lastoolspath[-1] != '\\':
            lastoolspath += '\\'

        cls.lastoolspath = lastoolspath
        cls.potreeconverterpath = pcpath

        configlines = ['lastools_path="' + lastoolspath + '"\n', 'potreeconverter_path="' + pcpath + '"']
        configfile.writelines(configlines)
        configfile.close()

    @classmethod
    def checkPathValidity(cls):
        print(cls.lastoolspath + r'bin\blast2dem.exe')
        print(os.path.isfile(cls.lastoolspath + r'bin\blast2dem.exe'))
        print(cls.potreeconverterpath + r'PotreeConverter.exe')
        print(os.path.isfile(cls.potreeconverterpath + r'PotreeConverter.exe'))
        if os.path.isfile(cls.lastoolspath + r'bin\blast2dem.exe') and os.path.isfile(cls.potreeconverterpath + r'PotreeConverter.exe'):
            print("return true")
            return True
        else:
            print("return false")
            return False



    @classmethod
    def blast2dem_thread_function(cls,input,output,cltype,stepsize,threadname):
        logging.info("Thread %s: starting", threadname)

        cmd = str(cls.lastoolspath + r'bin\blast2dem.exe -i '+input+' -o '+output+' -v '+cltype+' -step '+stepsize+'').split()
        print(cmd)

        subprocess.call(cmd, shell=False)

        logging.info("Thread %s: finishing", threadname)

    @classmethod
    def potreeconverter_thread_function(cls,input,output,outtype,pagename,proj,threadname='lol'):
        eov = ' "+proj=somerc +lat_0=47.14439372222222 +lon_0=19.04857177777778 +k_' \
            '0=0.99993 +x_0=650000 +y_0=200000 +ellps=GRS67 +towgs84=52.17,-71.82,-14.9,0,0,0,0 ' \
            '+units=m +no_defs "'
        # using a swiss projection. Use http://spatialreference.org/ to find projections in proj4 format
        # PotreeConverter.exe C:/data -o C:/potree_converted -p pageName --projection "+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=600000 +y_0=200000 +ellps=bessel +towgs84=674.4,15.1,405.3,0,0,0,0 +units=m +no_defs" --overwrite
        logging.info("Thread %s: starting", threadname)
        #print(threadname,input,cltype,stepsize)
        if (proj == None) or (proj == "+proj=longlat +datum=WGS84 +no_defs"):
            cmd = str(cls.potreeconverterpath + r'PotreeConverter.exe ' + input + ' -o ' + output + ' -a ' + outtype + ' --generate-page ' + pagename + '').split()
            #logfile.write(str(str(cls.potreeconverterpath + r'PotreeConverter.exe ' + input + ' -o ' + output + ' -a ' + outtype + ' --generate-page ' + pagename + '').split()))
            cmd[0] = cmd[0].replace("\\", "/")
            #print(str(cmd))
            subprocess.call(cmd, shell=False)
        else:
            cmd = str(cls.potreeconverterpath + r'PotreeConverter.exe ' + input + ' -o ' + output + ' -a ' + outtype + ' --generate-page ' + pagename + ' --projection "'+proj+'"').split()
            #logfile.write(str(str(cls.potreeconverterpath + r'PotreeConverter.exe ' + input + ' -o ' + output + ' -a ' + outtype + ' --generate-page ' + pagename + ' --projection "'+proj+'"').split()))
            #print(cmd)
            cmd[0] = cmd[0].replace("\\", "/")
            subprocess.call(cmd, shell=False)
        #subprocess.call(cmd, shell=False)

        logging.info("Thread is finishing")

    @classmethod
    def lasconvert_isready(cls, input, cltype, stepsize):
        timefortempname = datetime.now()
        output = 'cloud_'+str(timefortempname.strftime("%y%m%d%H%M%S"))+'.asc'
        PotreeCraftSupport.readcfg()

        format = "%(asctime)s: %(message)s"
        logging.basicConfig(format=format, level=logging.INFO,
                            datefmt="%H:%M:%S")
        #logging.info("Main    : before creating thread")
        x = threading.Thread(target=PotreeCraftSupport.blast2dem_thread_function, args=(input,(cls.potreeconverterpath + output) ,cltype,stepsize,"Blast2dem thread - "+output))
        #x = threading.Thread(target=PotreeCraftSupport.blast2dem_thread_function, args=(r'c:\PotreeConverter_16\3DModel_Pcld_LASCloud.las', 'caslte.asc', '-rgb', '0.1', 'asdf'))
        #logging.info("Main    : before running thread")
        x.start()
        #logging.info("Main    : wait for the thread to finish")
        x.join()
        #logging.info("Main    : all done")
        return output

    @classmethod
    def pcconvert_isready(cls, input,output,outtype,pagename,proj,threadname='lol'):
        timefortempname = datetime.now()

        #output = 'cloud_'+str(timefortempname.strftime("%y%m%d%H%M%S"))+'.asc'
        PotreeCraftSupport.readcfg()

        format = "%(asctime)s: %(message)s"
        logging.basicConfig(format=format, level=logging.INFO,
                            datefmt="%H:%M:%S")
        #logging.info("Main    : before creating thread")
        x = threading.Thread(target=PotreeCraftSupport.potreeconverter_thread_function, args=(input,output,outtype,pagename,proj,"PotreeConverter thread - "+threadname))
        #x = threading.Thread(target=PotreeCraftSupport.blast2dem_thread_function, args=(r'c:\PotreeConverter_16\3DModel_Pcld_LASCloud.las', 'caslte.asc', '-rgb', '0.1', 'asdf'))
        #logging.info("Main    : before running thread")
        x.start()
        #logging.info("Main    : wait for the thread to finish")
        x.join()
        #logging.info("Main    : all done")
        return output
    #
    # # TO DO
    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # megírni potreeconvert_isready metódust
    # az x-ben félkész de ott a változó
    # threading bugos pluginban megfagy felugró ablaktól... de végülis nem akkora baj
    # 2D kép már megy.
    # ha potree konvert is lefut, akkor jön a végső fázis:
    #
    # - shape és .js file másolás .html törlése/felülírása
    # - javascript editing
    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # js THREE point
    # https://threejs.org/docs/#api/en/objects/Points
    @classmethod
    def prepareProject(cls,projectPath,layerList):
        if not os.path.exists(projectPath+"/vector_data/"):
            os.makedirs(projectPath+"/vector_data/")
        print(projectPath)
        #copyfile("./shapefile-w3d.js", projectPath+"/libs/shapefile/")
        #os.path.isfile(file_path)
        try:
            cls.writeShapefileJs(projectPath+'libs/shapefile/')
        except:
            #win32file.CopyFile('./shapefile-w3d.js', projectPath+'libs/shapefile/',1)
            try:
                os.system("copy %s %s" % ('./shapefile-w3d.js', projectPath+'libs/shapefile/'))
            except:
                shutil.copy('./shapefile-w3d.js', projectPath + 'libs/shapefile/')
        for lyr in layerList:
            #print(lyr[0:-3])

            # .shp
            if os.path.isfile(lyr):
                shutil.copy2(lyr, projectPath + '/vector_data/')
            else:
                print(lyr + ' -- file not found')

            # .shx
            if os.path.isfile(lyr[0:-3]+'shx'):
                shutil.copy2(lyr[0:-3]+'shx', projectPath + '/vector_data/')
            else:
                print(lyr[0:-3]+'shx' + ' -- file not found')

            # .dbf
            if os.path.isfile(lyr[0:-3]+'dbf'):
                shutil.copy2(lyr[0:-3]+'dbf', projectPath + '/vector_data/')
            else:
                print(lyr[0:-3]+'dbf' + ' -- file not found')

            # .prj
            if os.path.isfile(lyr[0:-3]+'prj'):
                shutil.copy2(lyr[0:-3]+'prj', projectPath + '/vector_data/')
            else:
                print(lyr[0:-3]+'prj' + ' -- file not found')

            # .cpg
            if os.path.isfile(lyr[0:-3]+'cpg'):
                shutil.copy2(lyr[0:-3]+'cpg', projectPath + '/vector_data/')
            else:
                print(lyr[0:-3]+'cpg' + ' -- file not found')

            # .qpj
            if os.path.isfile(lyr[0:-3]+'qpj'):
                shutil.copy2(lyr[0:-3]+'qpj', projectPath + '/vector_data/')
            else:
                print(lyr[0:-3]+'qpj' + ' -- file not found')

    @classmethod
    def getFeatureData(cls,layer,titleField,descField):
        pts_features = layer.getFeatures()

        # preproc, feature id, coords and hnd/subcatch to table
        point_table = []
        for thisPoint in pts_features:
            pointGeom = thisPoint.geometry()
            pointID = thisPoint.id()
            wktpoint = pointGeom.asWkt()
            titleField_of_thisPoint = thisPoint[titleField]
            descField_of_thisPoint = thisPoint[descField]
            splitWktPoint = wktpoint.split(" ")
            print(splitWktPoint[0])
            if splitWktPoint[0].strip().upper() == 'POINTZ':
                rxpoint = round(float(splitWktPoint[1].replace('(', '')), 3)
                rypoint = round(float(splitWktPoint[2]), 3)
                rzpoint = round(float(splitWktPoint[3].replace(')', '')), 3)
                point_table.append([pointID, rxpoint, rypoint, rzpoint, str(titleField_of_thisPoint), str(descField_of_thisPoint)])
            elif splitWktPoint[0].strip().upper() == 'MULTIPOINT':
                pass

            # print(len(wktpoint))
            # print(str(wktpoint))
            # print(str(titleField_of_thisPoint))
            # print(str(descField_of_thisPoint))
            #for pointElem in xpoint:
            # rxpoint = round(wktpoint.get().x(), 2)
            # rypoint = round(wktpoint.get().y(), 2)
            # rzpoint = round(wktpoint.get().z(), 2)
            # point_table.append([pointID, rxpoint, rypoint, rzpoint,titleField_of_thisPoint,descField_of_thisPoint])
        for pt in (point_table):
            print(str(pt))
        return point_table

    @classmethod
    def writeHtml(cls,projecthtmlpath,cloudname,cloudparams,layerNameArray,layerColorArray,pageDescription,pointfunctionTable):
        # cloudparams[0]: coloring, pl 'INTENSITY'
        # cloudparams[1]: crs tömb, név és proj, pl ["WGS84", "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"], opcionális, default bejövőérték: None
        # cloudparams[2]: opacity? később.
        annoList = []
        for ptLayer in pointfunctionTable:
            if ptLayer[1] == 'Annotation':
                annoList.append(ptLayer[2].name())
        

        f = open(projecthtmlpath, "a")
        path = "./vector_data/"

        # -------------------------------------------------------------------------------------------------
        f.write('<!DOCTYPE html>\n')
        f.write('<html lang="en">\n')
        f.write('<head>\n')
        f.write('	<meta charset="utf-8">\n')
        f.write('	<meta name="description" content="">\n')
        f.write('	<meta name="author" content="">\n')
        f.write('	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">\n')
        f.write('	<title>Potree Viewer</title>\n')
        f.write('\n')
        f.write('	<link rel="stylesheet" type="text/css" href="libs/potree/potree.css">\n')
        f.write('	<link rel="stylesheet" type="text/css" href="libs/jquery-ui/jquery-ui.min.css">\n')
        f.write('	<link rel="stylesheet" type="text/css" href="libs/perfect-scrollbar/css/perfect-scrollbar.css">\n')
        f.write('	<link rel="stylesheet" type="text/css" href="libs/openlayers3/ol.css">\n')
        f.write('	<link rel="stylesheet" type="text/css" href="libs/spectrum/spectrum.css">\n')
        f.write('	<link rel="stylesheet" type="text/css" href="libs/jstree/themes/mixed/style.css">\n')
        f.write('</head>\n')
        f.write('\n')
        f.write('<body>\n')
        f.write('	<script src="libs/jquery/jquery-3.1.1.min.js"></script>\n')
        f.write('	<script src="libs/spectrum/spectrum.js"></script>\n')
        f.write('	<script src="libs/perfect-scrollbar/js/perfect-scrollbar.jquery.js"></script>\n')
        f.write('	<script src="libs/jquery-ui/jquery-ui.min.js"></script>\n')
        f.write('	<script src="libs/three.js/build/three.min.js"></script>\n')
        f.write('	<script src="libs/other/BinaryHeap.js"></script>\n')
        f.write('	<script src="libs/tween/tween.min.js"></script>\n')
        f.write('	<script src="libs/d3/d3.js"></script>\n')
        f.write('	<script src="libs/proj4/proj4.js"></script>\n')
        f.write('	<script src="libs/openlayers3/ol.js"></script>\n')
        f.write('	<script src="libs/i18next/i18next.js"></script>\n')
        f.write('	<script src="libs/jstree/jstree.js"></script>\n')
        f.write('	<script src="libs/potree/potree.js"></script>\n')
        f.write('	<script src="libs/plasio/js/laslaz.js"></script>\n')
        f.write('	<script src="libs/shapefile/shapefile-w3d.js"></script>\n')
        f.write('	\n')
        f.write('	\n')
        f.write('	<!-- INCLUDE ADDITIONAL DEPENDENCIES HERE -->\n')
        f.write('		document.title = "";\n')
        f.write('		viewer.setEDLEnabled(false);\n')
        f.write('		viewer.setBackground("gradient"); // ["skybox", "gradient", "black", "white"];\n')
        f.write('		viewer.setDescription(``);\n')
        f.write('	\n')
        f.write('	<div class="potree_container" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; ">\n')
        f.write('		<div id="potree_render_area"></div>\n')
        f.write('		<div id="potree_sidebar_container"> </div>\n')
        f.write('	</div>\n')
        f.write('	\n')
        f.write('	<script>\n')
        f.write('	\n')
        f.write('		window.viewer = new Potree.Viewer(document.getElementById("potree_render_area"));\n')
        f.write('		\n')
        f.write('		viewer.setEDLEnabled(true);\n')
        f.write('		viewer.setFOV(60);\n')
        f.write('		viewer.setPointBudget(1*1000*1000);\n')
        f.write('		document.title = "";\n')
        f.write('		viewer.setEDLEnabled(false);\n')
        f.write('		viewer.setBackground("gradient"); // ["skybox", "gradient", "black", "white"];\n')
        f.write('		viewer.setDescription(``);\n')
        f.write('		viewer.loadSettingsFromURL();\n')
        f.write('		\n')
        f.write('		viewer.loadGUI(() => {\n')
        f.write("			viewer.setLanguage('en');\n")
        f.write('			$("#menu_appearance").next().show();\n')
        f.write('			$("#menu_tools").next().show();\n')
        f.write('			$("#menu_scene").next().show();\n')
        f.write('			viewer.toggleSidebar();\n')
        f.write('		});\n')
        f.write('\n')
        f.write('		viewer.setDescription(`'+pageDescription+'`);\n')
        f.write('\n')
        f.write('		Potree.loadPointCloud("pointclouds/'+cloudname+'/cloud.js", "'+cloudname+'", e => {\n')
        f.write('			let pointcloud = e.pointcloud;\n')
        f.write('			let material = pointcloud.material;\n')
        f.write('			viewer.scene.addPointCloud(pointcloud);\n')
        f.write('			material.pointColorType = Potree.PointColorType.'+cloudparams[0]+'; // any Potree.PointColorType.XXXX \n')
        f.write('			material.size = 1;\n')
        f.write('			material.pointSizeType = Potree.PointSizeType.ATTENUATED;\n')
        f.write('			material.shape = Potree.PointShape.SQUARE;\n')
        f.write('			material.opacity = 0.08;\n')
        f.write('			//material.rgbGamma = 2.20;\n')
        f.write('			material.intensityGamma = 1.70;\n')
        f.write('			material.intensityRange = [25000,59000];\n')
        f.write('			material.intensityMin = 24200\n')
        f.write('\n')
        f.write('			// let pointcloudProjection = e.pointcloud.projection;\n')
        f.write('			// let mapProjection = proj4.defs("WGS84");\n')
        f.write('\n')
        f.write('			// window.toMap = proj4(pointcloudProjection, mapProjection);\n')
        f.write('			// window.toScene = proj4(mapProjection, pointcloudProjection);\n')
        f.write('\n')
        f.write('			viewer.fitToScreen();\n')
        f.write('			{\n')
        f.write('				// *** shape beolvasó kódrész ***\n')
        f.write('				// *** shape reading code section ***\n')
        f.write('\n')
        f.write('				//proj4.defs("pointcloud", pointcloud.projection);\n')
        f.write('				//proj4.defs("WGS84", "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs");\n')
        f.write('				//let toScene = proj4("WGS84", "pointcloud");\n')
        f.write('\n')
        f.write(
            '				// *** proj4 könyvtár jelen pillanatban nem működik ezzel a példával, figyelj rá, hogy minden felhasznált file megfelelő crs-ben van. ***\n')
        f.write(
            '				// *** proj4 library is currently not working with this example, make sure that all your files are in the right crs. ***\n')
        f.write('\n')
        f.write('				let featureToSceneNode = (feature, color) => {\n')
        f.write('					let geometry = feature.geometry;\n')
        f.write('\n')
        f.write('					var color = color ? color : new THREE.Color(1, 1, 1);\n')
        f.write('\n')
        f.write('					if(feature.geometry.type === "Point"){\n')
        f.write('						let measure = new Potree.Measure();\n')
        f.write('						//measure.name = "asdf";\n')
        f.write('						measure.showDistances = false;\n')
        f.write('						measure.showCoordinates = false;\n')
        f.write('				    	measure.closed = false;\n')
        f.write('						measure.showEdges = false;\n')
        f.write('						measure.color = color;\n')
        f.write('\n')
        f.write('						let [long, lat] = geometry.coordinates;\n')
        f.write('						let pos = ([long, lat]);\n')
        f.write('						let alt = geometry.coordinates[2]?geometry.coordinates[2]:20;\n')
        f.write('				    	measure.addMarker(new THREE.Vector3(pos[0], pos[1], alt));\n')
        f.write('\n')
        f.write('						return measure;\n')
        f.write('\n')

        f.write('					/*if(feature.geometry.type === "Point"){\n')
        f.write('						let sg = new THREE.SphereGeometry(1, 18, 18);\n')
        f.write('						let sm = new THREE.MeshNormalMaterial();\n')
        f.write('						let s = new THREE.Mesh(sg, sm);\n')
        f.write('\n')
        f.write('						let [long, lat] = geometry.coordinates;\n')
        f.write('						let pos = ([long, lat]);\n')
        f.write('						let alt = geometry.coordinates[2]?geometry.coordinates[2]:20;\n')
        f.write('						s.position.set(...pos, alt);\n')
        f.write('						s.scale.set(0.3, 0.3, 0.05);\n')
        f.write('\n')
        f.write('						return s;*/\n')
        f.write('					}else if(geometry.type === "LineString"){\n')
        f.write('						let coordinates = [];\n')
        f.write('						let min = new THREE.Vector3(Infinity, Infinity, Infinity);\n')
        f.write('\n')
        f.write('						for(let i = 0; i < geometry.coordinates.length; i++){\n')
        f.write('							let [long, lat] = geometry.coordinates[i];\n')
        f.write('							let pos = ([long, lat]);\n')
        f.write('\n')
        f.write('							//console.log("LSZ: ",pos, geometry.coordinates[i][2])\n')
        f.write('\n')
        f.write('							let alt = 20;\n')
        f.write('							min.x = Math.min(min.x, pos[0]);\n')
        f.write('							min.y = Math.min(min.y, pos[1]);\n')
        f.write('							min.z = Math.min(min.z, alt);\n')
        f.write('\n')
        f.write('							coordinates.push(...pos, alt);\n')
        f.write('							if(i > 0 && i < geometry.coordinates.length - 1){\n')
        f.write('								coordinates.push(...pos, alt);\n')
        f.write('							}\n')
        f.write('						}\n')
        f.write('\n')
        f.write('						for(let i = 0; i < coordinates.length; i += 3){\n')
        f.write('							coordinates[i+0] -= min.x;\n')
        f.write('							coordinates[i+1] -= min.y;\n')
        f.write('							coordinates[i+2] -= min.z;\n')
        f.write('						}\n')
        f.write('\n')
        f.write('						let positions = new Float32Array(coordinates);\n')
        f.write('						let lineGeometry = new THREE.BufferGeometry();\n')
        f.write('						lineGeometry.addAttribute("position", new THREE.BufferAttribute(positions, 3));\n')
        f.write('\n')
        f.write('						let material = new THREE.LineBasicMaterial( { color: color} );\n')
        f.write('						let line = new THREE.LineSegments(lineGeometry, material);\n')
        f.write('						line.position.copy(min);\n')
        f.write('\n')
        f.write('						return line;\n')
        f.write('\n')
        f.write('					}else if(geometry.type === "LineStringZ"){\n')
        f.write('						let coordinates = [];\n')
        f.write('						let min = new THREE.Vector3(Infinity, Infinity, Infinity);\n')
        f.write('\n')
        f.write('						for(let i = 0; i < geometry.coordinates.length; i++){\n')
        f.write('							let [long, lat] = geometry.coordinates[i];\n')
        f.write('							let pos = ([long, lat]);\n')
        f.write('\n')
        f.write('							//console.log("LSZ: ",pos, geometry.coordinates[i][2])\n')
        f.write('\n')
        f.write('							let alt = geometry.coordinates[i][2]?geometry.coordinates[i][2]:20;\n')
        f.write('							min.x = Math.min(min.x, pos[0]);\n')
        f.write('							min.y = Math.min(min.y, pos[1]);\n')
        f.write('							min.z = Math.min(min.z, alt);\n')
        f.write('\n')
        f.write('							coordinates.push(...pos, alt);\n')
        f.write('							if(i > 0 && i < geometry.coordinates.length - 1){\n')
        f.write('								coordinates.push(...pos, alt);\n')
        f.write('							}\n')
        f.write('						}\n')
        f.write('						for(let i = 0; i < coordinates.length; i += 3){\n')
        f.write('							coordinates[i+0] -= min.x;\n')
        f.write('							coordinates[i+1] -= min.y;\n')
        f.write('							coordinates[i+2] -= min.z;\n')
        f.write('						}\n')
        f.write('\n')
        f.write('						let positions = new Float32Array(coordinates);\n')
        f.write('						let lineGeometry = new THREE.BufferGeometry();\n')
        f.write('						lineGeometry.addAttribute("position", new THREE.BufferAttribute(positions, 3));\n')
        f.write('\n')
        f.write('						let material = new THREE.LineBasicMaterial( { color: color} );\n')
        f.write('						let line = new THREE.LineSegments(lineGeometry, material);\n')
        f.write('						line.position.copy(min);\n')
        f.write('\n')
        f.write('						return line;\n')
        f.write('\n')
        f.write('					}else if(geometry.type === "Polygon"){\n')
        f.write('						for(let pc of geometry.coordinates){\n')
        f.write('							let coordinates = [];\n')
        f.write('\n')
        f.write('							let min = new THREE.Vector3(Infinity, Infinity, Infinity);\n')
        f.write('							for(let i = 0; i < pc.length; i++){\n')
        f.write('								let [long, lat] = pc[i];\n')
        f.write('								let pos = ([long, lat]);\n')
        f.write('								let alt = pc[i][2]?pc[i][2]:20;\n')
        f.write('								min.x = Math.min(min.x, pos[0]);\n')
        f.write('								min.y = Math.min(min.y, pos[1]);\n')
        f.write('								min.z = Math.min(min.z, alt);\n')
        f.write('\n')
        f.write('								coordinates.push(...pos, alt);\n')
        f.write('								if(i > 0 && i < pc.length - 1){\n')
        f.write('									coordinates.push(...pos, alt);\n')
        f.write('								}\n')
        f.write('							}\n')
        f.write('\n')
        f.write('							for(let i = 0; i < coordinates.length; i += 3){\n')
        f.write('								coordinates[i+0] -= min.x;\n')
        f.write('								coordinates[i+1] -= min.y;\n')
        f.write('								coordinates[i+2] -= min.z;\n')
        f.write('							}\n')
        f.write('\n')
        f.write('							let positions = new Float32Array(coordinates);\n')
        f.write('\n')
        f.write('							let lineGeometry = new THREE.BufferGeometry();\n')
        f.write(
            '							lineGeometry.addAttribute("position", new THREE.BufferAttribute(positions, 3));\n')
        f.write('\n')
        f.write('							let material = new THREE.LineBasicMaterial( { color: color} );\n')
        f.write('							let line = new THREE.LineSegments(lineGeometry, material);\n')
        f.write('							line.position.copy(min);\n')
        f.write('\n')
        f.write('							return line;\n')
        f.write('						}\n')
        f.write('					}else{\n')
        f.write('						console.log("unhandled feature: ", feature);\n')
        f.write('					}\n')
        f.write('				};\n')
        f.write('\n')
        f.write('// --- automated output of shape layers --- \n')
        f.write('\n')



        for rowNo in range(len(layerNameArray)):
            if layerNameArray[rowNo] not in annoList:
                lyrHex = '999999'
                # row[1 ] -> shn_xx
                # row[2] -> nodeID_xx
                # path + row[0] -> ./shp/EP_Lepcso_line.shp"
                # lyrName -> EP_Lepcso_line
                # lyrHex -> A0522D


                f.write("				let shn_" + str(rowNo) + " = new THREE.Object3D();\n")
                f.write("				viewer.scene.scene.add(shn_" + str(rowNo) + ");\n")
                f.write('\n')

                f.write(
                    '			    Potree.utils.loadShapefileFeatures("' + path + layerNameArray[rowNo] + '.shp", features => {\n')
                f.write('					// feature-ök felláncolása\n')
                f.write('					// chaining up features\n')
                f.write('					for(let feature of features){\n')

                f.write('						let node = featureToSceneNode(feature, 0x' + layerColorArray[rowNo].replace("#","").upper() + ');\n')
                f.write('						shn_' + str(rowNo) + '.add(node);	\n')
                f.write('					}\n')
                f.write('					viewer.onGUILoaded(() => {\n')
                f.write('					let tree = $(`#jstree_scene`);\n')
                f.write('					let parentNode = "other";\n')
                f.write('					//console.log(tree);\n')
                f.write('\n')
                f.write("					let nodeID_" + str(rowNo) + " = tree.jstree('create_node', parentNode, { \n")
                f.write('						"text": "' + layerNameArray[rowNo] + '", \n')
                f.write('						"icon": `${Potree.resourcePath}/icons/triangle.svg`,\n')
                f.write('						"data": shn_' + str(rowNo) +'\n')
                f.write('					}, \n')
                f.write('					"last", false, false);\n')
                f.write(
                    '					tree.jstree(shn_' + str(rowNo) + '.visible ? "check_node" : "uncheck_node", nodeID_' + str(rowNo) + ');\n')
                f.write('					});\n')
                f.write('				});\n')

                f.write('\n')
        # annotations

        for ptLayer in pointfunctionTable:
            if ptLayer[1] == 'Annotation':
                preProcLayer = cls.getFeatureData(ptLayer[2],ptLayer[3],ptLayer[4])
                for annoPoint in preProcLayer:
                    #
                    # round(random.uniform(1,2), N)
                    # random kameratávot hozzáadni poshoz
                    #
                    cRandomx = round(random.uniform(ptLayer[5], ptLayer[6]), 3)
                    cRandomy = round(random.uniform(ptLayer[5], ptLayer[6]), 3)
                    f.write('				//  --- automated output of annotation points --- \n')
                    f.write('				{\n')
                    f.write('					let anno = new Potree.Annotation({\n')
                    f.write('						position: ['+str(annoPoint[1])+', '+str(annoPoint[2])+', '+str(annoPoint[3])+'],\n')
                    f.write('						cameraPosition: ['+str(annoPoint[1]+cRandomx)+', '+str(annoPoint[2]+cRandomy)+' , '+str(annoPoint[3]+5.0)+'],\n')
                    f.write('						cameraTarget: ['+str(annoPoint[1])+', '+str(annoPoint[2])+' ,'+str(annoPoint[3])+'],\n')
                    f.write('						title: "'+str(annoPoint[4])+'",\n')
                    f.write('						description: `'+str(annoPoint[5])+'`,\n')
                    f.write('					});\n')
                    f.write('					anno.domElement.off("mouseenter");\n')
                    f.write('					anno.domElement.off("mouseleave");\n')
                    f.write('					anno.addEventListener("click", () => {\n')
                    f.write('						anno.setHighlighted(!anno.isHighlighted);\n')
                    f.write('					});\n')
                    f.write('					viewer.scene.annotations.add(anno);\n')
                    f.write('				}\n')
                    f.write('\n')

        f.write('\n')
        f.write('			}\n')
        f.write('		});\n')
        f.write('	</script>\n')
        f.write('  </body>\n')
        f.write('</html>\n')

    @classmethod
    def writeShapefileJs(cls,shapefilejspath):
        print(shapefilejspath)
        print(shapefilejspath+'shapefile-w3d.js')
        f = open(shapefilejspath+'shapefile-w3d.js', "a")

        f.write('// this file was written by PotreeCraftSupport.writeShapefileJs function \n')
        f.write('(function (global, factory) {\n')
        f.write("	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n")
        f.write("	typeof define === 'function' && define.amd ? define(['exports'], factory) :\n")
        f.write('	(factory((global.shapefile = global.shapefile || {})));\n')
        f.write("}(this, (function (exports) { 'use strict';\n")
        f.write('\n')
        f.write('var array_cancel = function() {\n')
        f.write('  this._array = null;\n')
        f.write('  return Promise.resolve();\n')
        f.write('};\n')
        f.write('\n')
        f.write('var array_read = function() {\n')
        f.write('  var array = this._array;\n')
        f.write('  this._array = null;\n')
        f.write('  return Promise.resolve(array ? {done: false, value: array} : {done: true, value: undefined});\n')
        f.write('};\n')
        f.write('\n')
        f.write('function array(array) {\n')
        f.write('  return new ArraySource(array instanceof Uint8Array ? array : new Uint8Array(array));\n')
        f.write('}\n')
        f.write('\n')
        f.write('function ArraySource(array) {\n')
        f.write('  this._array = array;\n')
        f.write('}\n')
        f.write('\n')
        f.write('ArraySource.prototype.read = array_read;\n')
        f.write('ArraySource.prototype.cancel = array_cancel;\n')
        f.write('\n')
        f.write('var fetchPath = function(url) {\n')
        f.write('  return fetch(url).then(function(response) {\n')
        f.write('    return response.body && response.body.getReader\n')
        f.write('        ? response.body.getReader()\n')
        f.write('        : response.arrayBuffer().then(array);\n')
        f.write('  });\n')
        f.write('};\n')
        f.write('\n')
        f.write('var requestPath = function(url) {\n')
        f.write('  return new Promise(function(resolve, reject) {\n')
        f.write('    var request = new XMLHttpRequest;\n')
        f.write('    request.responseType = "arraybuffer";\n')
        f.write('    request.onload = function() { resolve(array(request.response)); };\n')
        f.write('    request.onerror = reject;\n')
        f.write('    request.ontimeout = reject;\n')
        f.write('    request.open("GET", url, true);\n')
        f.write('    request.send();\n')
        f.write('  });\n')
        f.write('};\n')
        f.write('\n')
        f.write('function path(path) {\n')
        f.write('  return (typeof fetch === "function" ? fetchPath : requestPath)(path);\n')
        f.write('}\n')
        f.write('\n')
        f.write('function stream(source) {\n')
        f.write('  return typeof source.read === "function" ? source : source.getReader();\n')
        f.write('}\n')
        f.write('\n')
        f.write('var empty = new Uint8Array(0);\n')
        f.write('\n')
        f.write('var slice_cancel = function() {\n')
        f.write('  return this._source.cancel();\n')
        f.write('};\n')
        f.write('\n')
        f.write('function concat(a, b) {\n')
        f.write('  if (!a.length) return b;\n')
        f.write('  if (!b.length) return a;\n')
        f.write('  var c = new Uint8Array(a.length + b.length);\n')
        f.write('  c.set(a);\n')
        f.write('  c.set(b, a.length);\n')
        f.write('  return c;\n')
        f.write('}\n')
        f.write('\n')
        f.write('var slice_read = function() {\n')
        f.write('  var that = this, array = that._array.subarray(that._index);\n')
        f.write('  return that._source.read().then(function(result) {\n')
        f.write('    that._array = empty;\n')
        f.write('    that._index = 0;\n')
        f.write('    return result.done ? (array.length > 0\n')
        f.write('        ? {done: false, value: array}\n')
        f.write('        : {done: true, value: undefined})\n')
        f.write('        : {done: false, value: concat(array, result.value)};\n')
        f.write('  });\n')
        f.write('};\n')
        f.write('\n')
        f.write('var slice_slice = function(length) {\n')
        f.write('  if ((length |= 0) < 0) throw new Error("invalid length");\n')
        f.write('  var that = this, index = this._array.length - this._index;\n')
        f.write('\n')
        f.write('  // If the request fits within the remaining buffer, resolve it immediately.\n')
        f.write('  if (this._index + length <= this._array.length) {\n')
        f.write('    return Promise.resolve(this._array.subarray(this._index, this._index += length));\n')
        f.write('  }\n')
        f.write('\n')
        f.write('  // Otherwise, read chunks repeatedly until the request is fulfilled.\n')
        f.write('  var array = new Uint8Array(length);\n')
        f.write('  array.set(this._array.subarray(this._index));\n')
        f.write('  return (function read() {\n')
        f.write('    return that._source.read().then(function(result) {\n')
        f.write('\n')
        f.write('      // When done, it’s possible the request wasn’t fully fullfilled!\n')
        f.write('      // If so, the pre-allocated array is too big and needs slicing.\n')
        f.write('      if (result.done) {\n')
        f.write('        that._array = empty;\n')
        f.write('        that._index = 0;\n')
        f.write('        return index > 0 ? array.subarray(0, index) : null;\n')
        f.write('      }\n')
        f.write('\n')
        f.write('      // If this chunk fulfills the request, return the resulting array.\n')
        f.write('      if (index + result.value.length >= length) {\n')
        f.write('        that._array = result.value;\n')
        f.write('        that._index = length - index;\n')
        f.write('        array.set(result.value.subarray(0, length - index), index);\n')
        f.write('        return array;\n')
        f.write('      }\n')
        f.write('\n')
        f.write('      // Otherwise copy this chunk into the array, then read the next chunk.\n')
        f.write('      array.set(result.value, index);\n')
        f.write('      index += result.value.length;\n')
        f.write('      return read();\n')
        f.write('    });\n')
        f.write('  })();\n')
        f.write('};\n')
        f.write('\n')
        f.write('function slice(source) {\n')
        f.write('  return typeof source.slice === "function" ? source :\n')
        f.write('      new SliceSource(typeof source.read === "function" ? source\n')
        f.write('          : source.getReader());\n')
        f.write('}\n')
        f.write('\n')
        f.write('function SliceSource(source) {\n')
        f.write('  this._source = source;\n')
        f.write('  this._array = empty;\n')
        f.write('  this._index = 0;\n')
        f.write('}\n')
        f.write('\n')
        f.write('SliceSource.prototype.read = slice_read;\n')
        f.write('SliceSource.prototype.slice = slice_slice;\n')
        f.write('SliceSource.prototype.cancel = slice_cancel;\n')
        f.write('\n')
        f.write('var dbf_cancel = function() {\n')
        f.write('  return this._source.cancel();\n')
        f.write('};\n')
        f.write('\n')
        f.write('var readBoolean = function(value) {\n')
        f.write('  return /^[nf]$/i.test(value) ? false\n')
        f.write('      : /^[yt]$/i.test(value) ? true\n')
        f.write('      : null;\n')
        f.write('};\n')
        f.write('\n')
        f.write('var readDate = function(value) {\n')
        f.write('  return new Date(+value.substring(0, 4), value.substring(4, 6) - 1, +value.substring(6, 8));\n')
        f.write('};\n')
        f.write('\n')
        f.write('var readNumber = function(value) {\n')
        f.write('  return !(value = value.trim()) || isNaN(value = +value) ? null : value;\n')
        f.write('};\n')
        f.write('\n')
        f.write('var readString = function(value) {\n')
        f.write('  return value.trim() || null;\n')
        f.write('};\n')
        f.write('\n')
        f.write('var types = {\n')
        f.write('  B: readNumber,\n')
        f.write('  C: readString,\n')
        f.write('  D: readDate,\n')
        f.write('  F: readNumber,\n')
        f.write('  L: readBoolean,\n')
        f.write('  M: readNumber,\n')
        f.write('  N: readNumber\n')
        f.write('};\n')
        f.write('\n')
        f.write('var dbf_read = function() {\n')
        f.write('  var that = this, i = 1;\n')
        f.write('  return that._source.slice(that._recordLength).then(function(value) {\n')
        f.write('    return value && (value[0] !== 0x1a) ? {done: false, value: that._fields.reduce(function(p, f) {\n')
        f.write('      p[f.name] = types[f.type](that._decode(value.subarray(i, i += f.length)));\n')
        f.write('      return p;\n')
        f.write('    }, {})} : {done: true, value: undefined};\n')
        f.write('  });\n')
        f.write('};\n')
        f.write('\n')
        f.write('var view = function(array) {\n')
        f.write('  return new DataView(array.buffer, array.byteOffset, array.byteLength);\n')
        f.write('};\n')
        f.write('\n')
        f.write('var dbf = function(source, decoder) {\n')
        f.write('  source = slice(source);\n')
        f.write('  return source.slice(32).then(function(array) {\n')
        f.write('    var head = view(array);\n')
        f.write('    return source.slice(head.getUint16(8, true) - 32).then(function(array) {\n')
        f.write('      return new Dbf(source, decoder, head, view(array));\n')
        f.write('    });\n')
        f.write('  });\n')
        f.write('};\n')
        f.write('\n')
        f.write('function Dbf(source, decoder, head, body) {\n')
        f.write('  this._source = source;\n')
        f.write('  this._decode = decoder.decode.bind(decoder);\n')
        f.write('  this._recordLength = head.getUint16(10, true);\n')
        f.write('  this._fields = [];\n')
        f.write('  for (var n = 0; body.getUint8(n) !== 0x0d; n += 32) {\n')
        f.write('    for (var j = 0; j < 11; ++j) if (body.getUint8(n + j) === 0) break;\n')
        f.write('    this._fields.push({\n')
        f.write('      name: this._decode(new Uint8Array(body.buffer, body.byteOffset + n, j)),\n')
        f.write('      type: String.fromCharCode(body.getUint8(n + 11)),\n')
        f.write('      length: body.getUint8(n + 16)\n')
        f.write('    });\n')
        f.write('  }\n')
        f.write('}\n')
        f.write('\n')
        f.write('var prototype = Dbf.prototype;\n')
        f.write('prototype.read = dbf_read;\n')
        f.write('prototype.cancel = dbf_cancel;\n')
        f.write('\n')
        f.write('function cancel() {\n')
        f.write('  return this._source.cancel();\n')
        f.write('}\n')
        f.write('\n')
        f.write('var readMultiPoint = function(record) {\n')
        f.write('  var i = 40, j, n = record.getInt32(36, true), coordinates = new Array(n);\n')
        f.write('  for (j = 0; j < n; ++j, i += 16) coordinates[j] = [record.getFloat64(i, true), record.getFloat64(i + 8, true)];\n')
        f.write('  return {type: "MultiPoint", coordinates: coordinates};\n')
        f.write('};\n')
        f.write('\n')
        f.write('var readNull = function() {\n')
        f.write('  return null;\n')
        f.write('};\n')
        f.write('\n')
        f.write('var readPoint = function(record) {\n')
        f.write('  return {type: "Point", coordinates: [record.getFloat64(4, true), record.getFloat64(12, true), record.getFloat64(20, true)]};\n')
        f.write('};\n')
        f.write('\n')
        f.write('var readPolygon = function(record) {\n')
        f.write('  var i = 44, j, n = record.getInt32(36, true), m = record.getInt32(40, true), parts = new Array(n), points = new Array(m), polygons = [], holes = [];\n')
        f.write('  for (j = 0; j < n; ++j, i += 4) parts[j] = record.getInt32(i, true);\n')
        f.write('  for (j = 0; j < m; ++j, i += 16) points[j] = [record.getFloat64(i, true), record.getFloat64(i + 8, true)];\n')
        f.write('\n')
        f.write('  parts.forEach(function(i, j) {\n')
        f.write('    var ring = points.slice(i, parts[j + 1]);\n')
        f.write('    if (ringClockwise(ring)) polygons.push([ring]);\n')
        f.write('    else holes.push(ring);\n')
        f.write('  });\n')
        f.write('\n')
        f.write('  holes.forEach(function(hole) {\n')
        f.write('    polygons.some(function(polygon) {\n')
        f.write('      if (ringContainsSome(polygon[0], hole)) {\n')
        f.write('        polygon.push(hole);\n')
        f.write('        return true;\n')
        f.write('      }\n')
        f.write('    }) || polygons.push([hole]);\n')
        f.write('  });\n')
        f.write('\n')
        f.write('  return polygons.length === 1\n')
        f.write('      ? {type: "Polygon", coordinates: polygons[0]}\n')
        f.write('      : {type: "MultiPolygon", coordinates: polygons};\n')
        f.write('};\n')
        f.write('\n')
        f.write('function ringClockwise(ring) {\n')
        f.write('  if ((n = ring.length) < 4) return false;\n')
        f.write('  var i = 0, n, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n')
        f.write('  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n')
        f.write('  return area >= 0;\n')
        f.write('}\n')
        f.write('\n')
        f.write('function ringContainsSome(ring, hole) {\n')
        f.write('  var i = -1, n = hole.length, c;\n')
        f.write('  while (++i < n) {\n')
        f.write('    if (c = ringContains(ring, hole[i])) {\n')
        f.write('      return c > 0;\n')
        f.write('    }\n')
        f.write('  }\n')
        f.write('  return false;\n')
        f.write('}\n')
        f.write('\n')
        f.write('function ringContains(ring, point) {\n')
        f.write('  var x = point[0], y = point[1], contains = -1;\n')
        f.write('  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n')
        f.write('    var pi = ring[i], xi = pi[0], yi = pi[1],\n')
        f.write('        pj = ring[j], xj = pj[0], yj = pj[1];\n')
        f.write('    if (segmentContains(pi, pj, point)) {\n')
        f.write('      return 0;\n')
        f.write('    }\n')
        f.write('    if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) {\n')
        f.write('      contains = -contains;\n')
        f.write('    }\n')
        f.write('  }\n')
        f.write('  return contains;\n')
        f.write('}\n')
        f.write('\n')
        f.write('function segmentContains(p0, p1, p2) {\n')
        f.write('  var x20 = p2[0] - p0[0], y20 = p2[1] - p0[1];\n')
        f.write('  if (x20 === 0 && y20 === 0) return true;\n')
        f.write('  var x10 = p1[0] - p0[0], y10 = p1[1] - p0[1];\n')
        f.write('  if (x10 === 0 && y10 === 0) return false;\n')
        f.write('  var t = (x20 * x10 + y20 * y10) / (x10 * x10 + y10 * y10);\n')
        f.write('  return t < 0 || t > 1 ? false : t === 0 || t === 1 ? true : t * x10 === x20 && t * y10 === y20;\n')
        f.write('}\n')
        f.write('\n')
        f.write('var readPolyLine = function(record) {\n')
        f.write('  var i = 44, j, n = record.getInt32(36, true), m = record.getInt32(40, true), parts = new Array(n), points = new Array(m);\n')
        f.write('  for (j = 0; j < n; ++j, i += 4) parts[j] = record.getInt32(i, true);\n')
        f.write('  for (j = 0; j < m; ++j, i += 16) points[j] = [record.getFloat64(i, true), record.getFloat64(i + 8, true)];\n')
        f.write('  return n === 1\n')
        f.write('      ? {type: "LineString", coordinates: points}\n')
        f.write('      : {type: "MultiLineString", coordinates: parts.map(function(i, j) { return points.slice(i, parts[j + 1]); })};\n')
        f.write('};\n')
        f.write('\n')
        f.write('var readPolyLineZ = function(record) {\n')
        f.write('	\n')
        f.write('  var i = 44, j, n = record.getInt32(36, true), m = record.getInt32(40, true), parts = new Array(n), points = new Array(m);\n')
        f.write('  for (j = 0; j < n; ++j, i += 4) parts[j] = record.getInt32(i, true);\n')
        f.write('  for (j = 0; j < m; ++j, i += 16) points[j] = [record.getFloat64(i, true), record.getFloat64(i + 8, true)];\n')
        f.write('  // Advance two doubles (z min, z max)\n')
        f.write('  i += 16;\n')
        f.write('  \n')
        f.write('  for (j = 0; j < m; ++j, i += 8) points[j].push(record.getFloat64(i, true)); \n')
        f.write('  \n')
        f.write('  return n === 1\n')
        f.write('      ? {type: "LineStringZ", coordinates: points}\n')
        f.write('      : {type: "MultiLineStringZ", coordinates: parts.map(function(i, j) { return points.slice(i, parts[j + 1]); })};\n')
        f.write('\n')
        f.write('};\n')
        f.write('\n')
        f.write('var shp_read = function() {\n')
        f.write('  var that = this;\n')
        f.write('  return that._source.slice(8).then(function(array) {\n')
        f.write('    if (array == null) return {done: true, value: undefined};\n')
        f.write('    var header = view(array);\n')
        f.write('    return that._source.slice(header.getInt32(4, false) * 2).then(function(array) {\n')
        f.write('      var record = view(array);\n')
        f.write('      return {done: false, value: record.getInt32(0, true) ? that._type(record) : readNull()};\n')
        f.write('    });\n')
        f.write('  });\n')
        f.write('};\n')
        f.write('\n')
        f.write('var types$1 = {\n')
        f.write('  0: readNull,\n')
        f.write('  1: readPoint,\n')
        f.write('  3: readPolyLine, //nincs z\n')
        f.write('  5: readPolygon,\n')
        f.write('  8: readMultiPoint,\n')
        f.write('  11: readPoint,\n')
        f.write('  13: readPolyLineZ,\n')
        f.write('  15: readPolygon,\n')
        f.write('  18: readMultiPoint\n')
        f.write('};\n')
        f.write('\n')
        f.write('var shp = function(source) {\n')
        f.write('  source = slice(source);\n')
        f.write('  return source.slice(100).then(function(array) {\n')
        f.write('    return new Shp(source, view(array));\n')
        f.write('  });\n')
        f.write('};\n')
        f.write('\n')
        f.write('function Shp(source, header) {\n')
        f.write('  var type = header.getInt32(32, true);\n')
        f.write('  if (!(type in types$1)) throw new Error("unsupported shape type: " + type + " "+ source);\n')
        f.write('  console.log(type + " --> " + source);\n')
        f.write('  this._source = source;\n')
        f.write('  this._type = types$1[type];\n')
        f.write('  this.bbox = [header.getFloat64(36, true), header.getFloat64(44, true), header.getFloat64(52, true), header.getFloat64(60, true)];\n')
        f.write('}\n')
        f.write('\n')
        f.write('var prototype$2 = Shp.prototype;\n')
        f.write('prototype$2.read = shp_read;\n')
        f.write('prototype$2.cancel = cancel;\n')
        f.write('\n')
        f.write('function noop() {}\n')
        f.write('\n')
        f.write('var shapefile_cancel = function() {\n')
        f.write('  return Promise.all([\n')
        f.write('    this._dbf && this._dbf.cancel(),\n')
        f.write('    this._shp.cancel()\n')
        f.write('  ]).then(noop);\n')
        f.write('};\n')
        f.write('\n')
        f.write('var shapefile_read = function() {\n')
        f.write('  var that = this;\n')
        f.write('  return Promise.all([\n')
        f.write('    that._dbf ? that._dbf.read() : {value: {}},\n')
        f.write('    that._shp.read()\n')
        f.write('  ]).then(function(results) {\n')
        f.write('    var dbf = results[0], shp = results[1];\n')
        f.write('    return shp.done ? shp : {\n')
        f.write('      done: false,\n')
        f.write('      value: {\n')
        f.write('        type: "Feature",\n')
        f.write('        properties: dbf.value,\n')
        f.write('        geometry: shp.value\n')
        f.write('      }\n')
        f.write('    };\n')
        f.write('  });\n')
        f.write('};\n')
        f.write('\n')
        f.write('var shapefile = function(shpSource, dbfSource, decoder) {\n')
        f.write('  return Promise.all([\n')
        f.write('    shp(shpSource),\n')
        f.write('    dbfSource && dbf(dbfSource, decoder)\n')
        f.write('  ]).then(function(sources) {\n')
        f.write('    return new Shapefile(sources[0], sources[1]);\n')
        f.write('  });\n')
        f.write('};\n')
        f.write('\n')
        f.write('function Shapefile(shp$$1, dbf$$1) {\n')
        f.write('  this._shp = shp$$1;\n')
        f.write('  this._dbf = dbf$$1;\n')
        f.write('  this.bbox = shp$$1.bbox;\n')
        f.write('}\n')
        f.write('\n')
        f.write('var prototype$1 = Shapefile.prototype;\n')
        f.write('prototype$1.read = shapefile_read;\n')
        f.write('prototype$1.cancel = shapefile_cancel;\n')
        f.write('\n')
        f.write('function open(shp$$1, dbf$$1, options) {\n')
        f.write('  if (typeof dbf$$1 === "string") {\n')
        f.write('    if (!/\.dbf$/.test(dbf$$1)) dbf$$1 += ".dbf";\n')
        f.write('    dbf$$1 = path(dbf$$1, options);\n')
        f.write('  } else if (dbf$$1 instanceof ArrayBuffer || dbf$$1 instanceof Uint8Array) {\n')
        f.write('    dbf$$1 = array(dbf$$1);\n')
        f.write('  } else if (dbf$$1 != null) {\n')
        f.write('    dbf$$1 = stream(dbf$$1);\n')
        f.write('  }\n')
        f.write('  if (typeof shp$$1 === "string") {\n')
        f.write('    if (!/\.shp$/.test(shp$$1)) shp$$1 += ".shp";\n')
        f.write('    if (dbf$$1 === undefined) dbf$$1 = path(shp$$1.substring(0, shp$$1.length - 4) + ".dbf", options).catch(function() {});\n')
        f.write('    shp$$1 = path(shp$$1, options);\n')
        f.write('  } else if (shp$$1 instanceof ArrayBuffer || shp$$1 instanceof Uint8Array) {\n')
        f.write('    shp$$1 = array(shp$$1);\n')
        f.write('  } else {\n')
        f.write('    shp$$1 = stream(shp$$1);\n')
        f.write('  }\n')
        f.write('  return Promise.all([shp$$1, dbf$$1]).then(function(sources) {\n')
        f.write('    var shp$$1 = sources[0], dbf$$1 = sources[1], encoding = "windows-1252";\n')
        f.write('    if (options && options.encoding != null) encoding = options.encoding;\n')
        f.write('    return shapefile(shp$$1, dbf$$1, dbf$$1 && new TextDecoder(encoding));\n')
        f.write('  });\n')
        f.write('}\n')
        f.write('\n')
        f.write('function openShp(source, options) {\n')
        f.write('  if (typeof source === "string") {\n')
        f.write('    if (!/\.shp$/.test(source)) source += ".shp";\n')
        f.write('    source = path(source, options);\n')
        f.write('  } else if (source instanceof ArrayBuffer || source instanceof Uint8Array) {\n')
        f.write('    source = array(source);\n')
        f.write('  } else {\n')
        f.write('    source = stream(source);\n')
        f.write('  }\n')
        f.write('  return Promise.resolve(source).then(shp);\n')
        f.write('}\n')
        f.write('\n')
        f.write('function openDbf(source, options) {\n')
        f.write('  var encoding = "windows-1252";\n')
        f.write('  if (options && options.encoding != null) encoding = options.encoding;\n')
        f.write('  encoding = new TextDecoder(encoding);\n')
        f.write('  if (typeof source === "string") {\n')
        f.write('    if (!/\.dbf$/.test(source)) source += ".dbf";\n')
        f.write('    source = path(source, options);\n')
        f.write('  } else if (source instanceof ArrayBuffer || source instanceof Uint8Array) {\n')
        f.write('    source = array(source);\n')
        f.write('  } else {\n')
        f.write('    source = stream(source);\n')
        f.write('  }\n')
        f.write('  return Promise.resolve(source).then(function(source) {\n')
        f.write('    return dbf(source, encoding);\n')
        f.write('  });\n')
        f.write('}\n')
        f.write('\n')
        f.write('function read(shp$$1, dbf$$1, options) {\n')
        f.write('  return open(shp$$1, dbf$$1, options).then(function(source) {\n')
        f.write('    var features = [], collection = {type: "FeatureCollection", features: features, bbox: source.bbox};\n')
        f.write('    return source.read().then(function read(result) {\n')
        f.write('      if (result.done) return collection;\n')
        f.write('      features.push(result.value);\n')
        f.write('      return source.read().then(read);\n')
        f.write('    });\n')
        f.write('  });\n')
        f.write('}\n')
        f.write('\n')
        f.write('exports.open = open;\n')
        f.write('exports.openShp = openShp;\n')
        f.write('exports.openDbf = openDbf;\n')
        f.write('exports.read = read;\n')
        f.write('\n')
        f.write("Object.defineProperty(exports, '__esModule', { value: true });\n")
        f.write('\n')
        f.write('})));\n')


if __name__ == "__main__":
    pass





